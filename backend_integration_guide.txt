# Outstanding Tracker: Complete Backend Integration Guide

This document provides the full technical specifications for building a Node.js/Express/MongoDB backend that is compatible with the existing Next.js frontend of the Outstanding Tracker application.

======================================
1. System Design & Architecture
======================================

### 1.1. Tech Stack (MERN)
- **Runtime**: Node.js
- **Framework**: Express.js
- **Database**: MongoDB (with Mongoose for Object Data Modeling)
- **Authentication**: JSON Web Tokens (JWT)

### 1.2. Proposed Backend Project Structure
/
├── backend/
│   ├── config/             # Environment variables, database connection (db.js)
│   ├── controllers/        # Request handlers containing all business logic
│   ├── middleware/         # Custom middleware (e.g., JWT verification, error handling)
│   ├── models/             # Mongoose schemas for MongoDB data models
│   ├── routes/             # API route definitions that link to controllers
│   └── server.js           # Main Express server entry point

======================================
2. Data Models & Schema (Mongoose)
======================================

### 2.1. User Model (`models/User.js`)
```javascript
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // Should be stored as a hash
  role: { 
    type: String, 
    enum: ['Manager', 'Engineer', 'Country Manager', 'Admin'], 
    required: true 
  },
  region: { 
    type: String, 
    enum: ['ahmedabad','banglore','chennai','delhi','export','goa','hyderabad','indore','jaipur','kolkata','mumbai','nagpur','odisha','pune','punjab','raipur','vizag','wie']
  },
  contact: { type: String }
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);
```

### 2.2. Customer Model (`models/Customer.js`)
```javascript
const mongoose = require('mongoose');

const customerSchema = new mongoose.Schema({
  customerCode: { type: String, required: true, unique: true },
  customerName: { type: String, required: true },
  region: { type: String, required: true },
  outstandingAmount: { type: Number, default: 0 },
  remarks: { 
    type: String, 
    enum: ["payment received", "partial payment", "under follow-up", "dispute", "write-off", "none"],
    default: 'none'
  },
  notes: { type: String, default: '' },
  assignedEngineer: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
}, { timestamps: true });

module.exports = mongoose.model('Customer', customerSchema);
```

### 2.3. Invoice Model (`models/Invoice.js`)
```javascript
const mongoose = require('mongoose');

const invoiceSchema = new mongoose.Schema({
  invoiceNumber: { type: String, required: true, unique: true },
  invoiceAmount: { type: Number, required: true },
  invoiceDate: { type: Date, required: true },
  status: { 
    type: String, 
    enum: ['paid', 'unpaid', 'dispute'], 
    default: 'unpaid' 
  },
  customer: { type: mongoose.Schema.Types.ObjectId, ref: 'Customer', required: true }
}, { timestamps: true });

module.exports = mongoose.model('Invoice', invoiceSchema);
```

======================================
3. Authentication Flow (JWT)
======================================
- **Login (`POST /api/auth/login`):**
    1. User submits email and password.
    2. Backend finds user by email, then compares the submitted password with the hashed password in the database (using a library like `bcrypt`).
    3. On success, it generates a JWT containing the user's ID, role, and other non-sensitive info. The token should have an expiration date.
    4. The JWT is sent back to the frontend.
- **Frontend Storage**: The frontend stores the JWT in `localStorage` or a secure cookie.
- **Authenticated Requests**: For all protected API calls, the frontend sends the JWT in the `Authorization: Bearer <token>` header.
- **Backend Middleware (`middleware/auth.js`):** An Express middleware on the backend verifies the incoming JWT on protected routes. If the token is valid, it decodes the payload and attaches the user's information to the request object (e.g., `req.user`), which can then be used by controllers for authorization.

======================================
4. API Endpoint Specifications
======================================

### 4.1. General Setup
- **Base API URL Expectation**: The frontend is configured to make requests to a base URL. For local development, this would typically be `http://localhost:5000/api`.
- **CORS**: The backend server must be configured with the `cors` middleware to accept requests from the frontend's origin (e.g., `http://localhost:9002` in development).

### 4.2. Authentication Endpoints
- **Endpoint**: `POST /api/auth/login`
- **Request Body**: `{ "email": "user@example.com", "password": "user_password" }`
- **Success Response (200 OK)**:
  ```json
  {
    "token": "your_jwt_token_here",
    "user": {
      "id": "user_mongodb_object_id",
      "name": "User Name",
      "role": "Manager",
      "department": "Batching Plant"
    }
  }
  ```
- **Error Response (400/401)**: `{ "error": "Invalid email or password." }`

### 4.3. Main Data API Endpoints (Protected)
- **Get Dashboard Data**: `GET /api/dashboard`
  - **Query Params**: `month`, `department`, `financialYear`.
  - **Success Response (200 OK)**: Should return a JSON object with `kpis`, `outstandingByAge`, `regionDistribution`, and `monthlyTrends`.

- **Get Customers (for Data Sheet)**: `GET /api/customers`
  - **Query Params**: `department`, `financialYear`.
  - **Success Response (200 OK)**: Return an array of `Customer` objects, populating the `invoices` array for each customer.

- **Get Invoice Tracker Data**: `GET /api/invoice-tracker`
  - **Query Params**: `region`, `department`, `financialYear`.
  - **Success Response (200 OK)**: Return an array matching `InvoiceTrackerData` type.

- **Get All Users (for Team Hierarchy)**: `GET /api/users`
  - **Success Response (200 OK)**: Return an array of all `User` objects.

### 4.4. Data Mutation Endpoints (Protected)
- **Update Customer Remark**: `PUT /api/customers/:id/remark`
  - **Request Body**: `{ "newRemark": "payment received" }`
  - **Success Response**: `200 OK` with `{ "success": true }`

- **Update Customer Notes**: `PUT /api/customers/:id/notes`
  - **Request Body**: `{ "newNotes": "Customer promised payment by EOD." }`
  - **Success Response**: `200 OK` with `{ "success": true }`

- **Update Assigned Engineer**: `PUT /api/customers/:id/assign-engineer`
  - **Request Body**: `{ "engineerId": "mongodb_object_id_of_engineer" }`
  - **Success Response**: `200 OK` with `{ "success": true }`

- **Update Invoice Dispute Status**: `PUT /api/customers/:customerId/invoices/:invoiceNumber/dispute`
  - **Request Body**: `{ "newStatus": "dispute" }` (Can be 'dispute', 'unpaid', 'paid')
  - **Success Response**: `200 OK` with `{ "success": true }`

### 4.5. File Upload Endpoint (Protected)
- **Endpoint**: `POST /api/upload`
- **Request Type**: `multipart/form-data`
- **Form Fields**: `file` (the `.xlsx` file), `month`, `financialYear`.
- **Backend Logic**:
  1. Use a library like `multer` to handle the file stream.
  2. Use `xlsx` or `exceljs` to parse the Excel data into records.
  3. Save the parsed data to the database, associating it with the correct customer, month, and financial year.
  4. Role-based access control middleware should ensure only 'Country Manager' or 'Admin' can use this endpoint.
- **Success Response (200 OK)**: `{ "count": 150, "message": "Upload successful." }`
- **Error Response (400/500)**: `{ "error": "File processing failed." }`

======================================
5. Important Guidelines (What Not to Do)
======================================
- **Do not store sensitive information in JWT payloads**: Only non-sensitive data like user ID and role should be in the token.
- **Do not perform critical business logic on the frontend**: All calculations, data validation, and aggregation should be handled by the Express.js backend. The frontend should only be responsible for presenting data and capturing user input.
- **Do not trust client-side validation alone**: While the frontend should have form validation for a good UX, all incoming data must be re-validated on the backend before being saved to the database.
- **Do not expose raw database errors to the user**: Use a centralized error handler in Express to catch errors and send generic, friendly error messages to the frontend.

With these specifications, you can build a backend that will seamlessly integrate with the frontend application. Good luck!
